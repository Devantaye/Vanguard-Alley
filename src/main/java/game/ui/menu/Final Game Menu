package com.example.gamemenu;

import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.util.List;
import javax.swing.*;
import javax.swing.Timer;

public class GameMenu extends JPanel implements ActionListener, SettingsChangeListener 
{
    private Timer timer;
    private JButton playButton, volumeButton, rulesButton, creditsButton, exitButton;
    private MusicPlayer music = new MusicPlayer();
    private static GameMenu mainMenu;
    private java.util.List<Bullet> bullets = new ArrayList<>();
    
    // Maze definition (28 rows x 36 cols, 1 = wall, 0 = path)
    private final int[][] maze = 
    {
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
        {1,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1},
        {1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,1,0,1,0,0,0,0,0,0,1},
        {1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1},
        {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
        {1,0,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1},
        {1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1},
        {1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1},
        {1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1},
        {1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1},
        {1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1},
        {1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0},
        {1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0},
        {1,0,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0},
        {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        // Aligned another maze 14(rows)x 36(columns) to fit the screen
        {1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1},
        {1,0,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1},
        {1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1},
        {1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1},
        {1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1},
        {1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1},
        {1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1},
        {1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0},
        {1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0},
        {1,0,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0},
        {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
    };

    private final int cellSize = 30;
    private Tank player;
    private java.util.List<Tank> enemies = new ArrayList<>();
    private Random rand = new Random();

    public GameMenu() 
    {
        setLayout(null);
        
        if (mainMenu == null)
        {
            mainMenu = this;
        }
        
        //music file
        music.init("res/menu_music.wav");

        // Buttons
        playButton     = createButton("Play",     300, 200);
        volumeButton   = createButton("Volume", 300, 270);
        rulesButton    = createButton("Rules",    300, 340);
        creditsButton  = createButton("Credits",  300, 410);
        exitButton     = createButton("Exit",     300, 480);

        
        add(playButton);
        add(volumeButton);
        add(rulesButton);
        add(creditsButton);
        add(exitButton);

        // Tanks
        player = new Tank(1, 1, Color.WHITE, true);
        spawnEnemy();

        // Timer for animation
        timer = new Timer(200, this);
        timer.start();
    }

    private JButton createButton(String text, int x, int y) 
    {
        JButton btn = new JButton(text);
        btn.setBounds(x, y, 200, 50);
        btn.setFocusPainted(false);
        btn.setFont(new Font("Monospaced", Font.BOLD, 20));
        btn.addActionListener(e -> handleButtonClick(text));
        return btn;
    }

    private void handleButtonClick(String buttonText) 
    {
        JFrame parent = (JFrame) SwingUtilities.getWindowAncestor(this);

        switch (buttonText) 
        {
            case "Play":
                System.out.println("Play the game!");
                break;

            case "Volume":
                SettingsDialog dlg = new SettingsDialog(parent, this);
                dlg.pack();
                dlg.setLocationRelativeTo(parent);
                dlg.setVisible(true);
                break;

            case "Rules":
                Rules rulesPanel = new Rules(e -> 
                {
                    // Go back to the menu
                    parent.getContentPane().removeAll();
                    parent.add(mainMenu);
                    parent.revalidate();
                    parent.repaint();
                });

                parent.getContentPane().removeAll();
                parent.add(rulesPanel);
                parent.revalidate();
                parent.repaint();
                break;
                
             case "Credits":
                Credits creditsPanel = new Credits(e -> 
                {
                    // Go back to the menu
                    parent.getContentPane().removeAll();
                    parent.revalidate();
                    parent.add(mainMenu);
                    parent.repaint();
                });

                parent.getContentPane().removeAll();
                parent.add(creditsPanel);
                parent.revalidate();
                parent.repaint();
                break;

            case "Exit":
                System.exit(0);
                break;
        }
    }
    
    @Override
    public void onVolumeChanged(int level) 
    {
        float vol = Math.max(0f, Math.min(1f, level / 10f));
        music.setVolume(vol);
    }

@Override
protected void paintComponent(Graphics g) 
{
    super.paintComponent(g);
    
    Graphics2D g2 = (Graphics2D) g;

    g2.setColor(Color.GRAY);
    g2.fillRect(0, 0, getWidth(), getHeight());

    // Calculate dynamic cell size to fit the panel
    int rows = maze.length;
    int cols = maze[0].length;
    int cellWidth = getWidth() / cols;
    int cellHeight = getHeight() / rows;
    int cellSize = Math.min(cellWidth, cellHeight); // Keep cells square

    // Draw maze
    for (int r = 0; r < rows; r++) 
    {
        for (int c = 0; c < cols; c++) 
        {
            if (maze[r][c] == 1) 
            {
                g2.setColor(Color.DARK_GRAY);
            } 
            else 
            {
                g2.setColor(Color.BLACK);
            }
            g2.fillRect(c * cellSize, r * cellSize, cellSize, cellSize);
        }
    }

    // Draw tanks
    player.draw(g2, cellSize);
    for (Tank e : enemies) e.draw(g2, cellSize);

    // Draw Title
    String title = "VANGUARD ALLEY";
    Font font = new Font("Monospaced", Font.BOLD, 48);
    g2.setFont(font);
    g2.setColor(Color.GREEN.darker());

    FontMetrics fm = g2.getFontMetrics(font);
    int textWidth = fm.stringWidth(title);

    // Center horizontally
    int x = (getWidth() - textWidth) / 2;

    // Position vertically just above Play button
    int playButtonY = 150;   // <<< change this to your actual Play button Y
    int gap = 20;            // distance between title and Play button
    int y = playButtonY - gap;

    // Draw
    g2.drawString(title, x, y);

}

@Override
public void actionPerformed(ActionEvent e) 
{
    // Move player randomly (demo only, you can change to WASD later)
    player.randomMove();

    for (Tank enemy : enemies) 
    {
        if (rand.nextInt(5) == 0) 
        {
            // 20% chance: chase the player
            enemy.chase(player);
        } 
        else 
        {
            // 80% chance: wander randomly
            enemy.randomMove();
        }

        // Check collision
        if (enemy.row == player.row && enemy.col == player.col) 
        {
            respawnPlayer();
            break;
        }
    }

    // Occasionally spawn new enemy
    if (rand.nextInt(30) == 0 && enemies.size() < 5) {
        spawnEnemy();
    }

    repaint();
}


private void respawnPlayer() 
{
    int r, c;
    
    do 
    {
        r = rand.nextInt(maze.length);
        c = rand.nextInt(maze[0].length);
    } 
    while (maze[r][c] == 1);  // ensure not respawn in a wall
    
    player.row = r;
    player.col = c;
}



    private void spawnEnemy() 
    {
        int r, c;
        
        do 
        {
            r = rand.nextInt(maze.length);
            c = rand.nextInt(maze[0].length);
        } 
        while (maze[r][c] == 1 || (r == 1 && c == 1));
        
        enemies.add(new Tank(c, r, Color.RED, false));
    }

    public static void main(String[] args) 
    {
        JFrame frame = new JFrame("Vanguard Alley");
        GameMenu mainMenu = new GameMenu();
        frame.add(mainMenu);
        frame.setSize(800, 650);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setResizable(false);
        frame.setVisible(true);
    }
    
    // ================= Tank Class =================
    private class Tank 
    {
        int col, row;
        Color color;
        boolean isPlayer;

        Tank(int col, int row, Color color, boolean isPlayer) 
        {
            this.col = col;
            this.row = row;
            this.color = color;
            this.isPlayer = isPlayer;
        }

        void draw(Graphics2D g2, int cellSize) 
        {
            int x = col * cellSize;
            int y = row * cellSize;

            // ===== Tank Body =====
            g2.setColor(color);
            g2.fillRect(x + cellSize/6, y + cellSize/6, 
                        cellSize * 2/3, cellSize * 2/3);

            // ===== Tracks =====
            g2.setColor(Color.GRAY);
            g2.fillRect(x, y + cellSize/6, cellSize/6, cellSize * 2/3);              // left track
            g2.fillRect(x + (cellSize * 5/6), y + cellSize/6, cellSize/6, cellSize * 2/3); // right track

            // ===== Turret (circle in the middle) =====
            g2.setColor(Color.DARK_GRAY);
            int turretSize = cellSize / 3;
            g2.fillOval(x + cellSize/2 - turretSize/2, 
                        y + cellSize/2 - turretSize/2, 
                        turretSize, turretSize);

            // ===== Cannon (barrel facing upward by default) =====
            g2.setColor(Color.BLACK);
            int barrelWidth = cellSize / 8;
            int barrelLength = cellSize / 2;
            g2.fillRect(x + cellSize/2 - barrelWidth/2, 
                        y, 
                        barrelWidth, 
                        barrelLength);
        }

        void randomMove() 
        {
            int[][] dirs = {{0,-1},{1,0},{0,1},{-1,0}}; // up, right, down, left
            List<int[]> directions = Arrays.asList(dirs);
            Collections.shuffle(directions);

            for (int[] d : directions) 
            {
                int nr = row + d[1], nc = col + d[0];

                //Only moves if inside bounds AND not a wall
                if (nr >= 0 && nr < maze.length && nc >= 0 && nc < maze[0].length && maze[nr][nc] == 0) 
                {
                    row = nr;
                    col = nc;
                    break;
                }
            }
        }
        
        void shootAt(Tank target) 
        {
            int dRow = Integer.signum(target.row - row);
            int dCol = Integer.signum(target.col - col);
            
            if (dRow == 0 || dCol == 0) 
            { // straight line only
                bullets.add(new Bullet(row, col, dRow, dCol, color));
            }
        }


        void chase(Tank target) 
        {
            int newRow = row, newCol = col;

            if (Math.abs(target.row - row) > Math.abs(target.col - col)) 
            {
                newRow += Integer.signum(target.row - row);
            } 
            else 
            {
                newCol += Integer.signum(target.col - col);
            }

            // Move only if not a wall
            if (maze[newRow][newCol] == 0) 
            {
                row = newRow;
                col = newCol;
            }
        }
    }
    
    // ===== Bullet Class =====
    private class Bullet 
    {
        int row, col, dRow, dCol;
        Color color;
        boolean active = true;

        Bullet(int row, int col, int dRow, int dCol, Color color) {
            this.row = row; this.col = col;
            this.dRow = dRow; this.dCol = dCol;
            this.color = color;
        }

        void move() 
        {
            int newRow = row + dRow;
            int newCol = col + dCol;
            if (newRow < 0 || newRow >= maze.length ||
                newCol < 0 || newCol >= maze[0].length ||
                maze[newRow][newCol] == 1) {
                active = false;
                return;
            }
            row = newRow; col = newCol;
        }

        void draw(Graphics2D g2, int cellSize) 
        {
            if (!active) return;
            g2.setColor(color);
            g2.fillOval(col * cellSize + cellSize/3, row * cellSize + cellSize/3, cellSize/3, cellSize/3);
        }
    }

    // ===== Line of Sight =====
    private boolean hasLineOfSight(Tank a, Tank b) 
    {
        if (a.row == b.row) 
        {
            int min = Math.min(a.col, b.col), max = Math.max(a.col, b.col);
            for (int c = min + 1; c < max; c++) if (maze[a.row][c] == 1) return false;
            return true;
        } 
        else if (a.col == b.col) 
        {
            int min = Math.min(a.row, b.row), max = Math.max(a.row, b.row);
            for (int r = min + 1; r < max; r++) if (maze[r][a.col] == 1) return false;
            return true;
        }
        return false;
    }
}
